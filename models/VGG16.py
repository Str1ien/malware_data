#!/usr/bin/env python
# coding: utf-8

# Librerías necesarias
import tensorflow as tf
import os
import numpy as np
import sklearn as sk
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, LeakyReLU, PReLU
from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input
from keras.initializers import Constant
from tensorflow.keras import regularizers
from glob import glob
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
import pandas as pd

# Rutas de las imágenes de entrenamiento y prueba
train_dir = 'data_malevis/train'
test_dir = 'data_malevis/val'

# Parámetros de preprocesamiento de imágenes
image_size = (224, 224)  # Tamaño deseado de las imágenes
batch_size = 32          # Tamaño del lote para el entrenamiento

# Generadores de datos para cargar y preprocesar las imágenes de entrenamiento y prueba
train_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)
test_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=image_size,
    batch_size=batch_size,
    class_mode='categorical')

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=image_size,
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=False)

# Para obtener las clases de salida
classes = glob('malware_detection/data_malevis/train/*')

# Número de clases de salida
num_classes = len(classes)

# Arquitectura de la red neuronal 1 (VGG16 con última capa adaptada)
base_model = VGG16(include_top=True, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))
model1 = Sequential()

# Añadir al modelo todas menos la última
for layer in base_model.layers[:-1]:
  model1.add(layer)

# Congelar las ya entrenadas
for layer in model1.layers:
  layer.trainable=False

# Última capa
model1.add(Dense(num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model1.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model1.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model1.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model1.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model1_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model1_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model1_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 2 (VGG16 + nuevas capas de clasificación con RELU)
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

# Freeze convolutinal layers
base_model.trainable = False

model2 = Sequential()

for layer in base_model.layers:
  model2.add(layer)

# Capas sustituidas
model2.add(Flatten())
model2.add(Dense(units=4096, activation='relu'))
model2.add(Dense(units=4096, activation='relu'))
model2.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model2.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model2.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model2.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model2.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model2_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model2_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model2_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 3 (VGG16 + nuevas capas de clasificación con Leaky RELU)
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

base_model.trainable = False

model3 = Sequential()

for layer in base_model.layers:
  model3.add(layer)

# Capas sustituidas
model3.add(Flatten())
model3.add(Dense(4096))
model3.add(LeakyReLU(0.2))
model3.add(Dense(4096))
model3.add(LeakyReLU(0.2))
model3.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model3.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model3.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model3.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model3.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model3_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model3_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model3_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 4 (VGG16 + nuevas capas de clasificación con SELU)
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

base_model.trainable = False

model4 = Sequential()

for layer in base_model.layers:
  model4.add(layer)

# Capas sustituidas
model4.add(Flatten())
model4.add(Dense(units=4096, activation='selu'))
model4.add(Dense(units=4096, activation='selu'))
model4.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo

model4.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model4.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model4.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model4.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model4_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model4_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model4_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 5 (VGG16 + nuevas capas de clasificación con PReLU (inicializador Constant))
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

base_model.trainable = False

model5 = Sequential()

for layer in base_model.layers:
  model5.add(layer)

# Capas sustituidas
model5.add(Flatten())
model5.add(Dense(4096))
model5.add(PReLU(alpha_initializer=Constant(value=0.25)))
model5.add(Dense(4096))
model5.add(PReLU(alpha_initializer=Constant(value=0.25)))
model5.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model5.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model5.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model5.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model5.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model5_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)

plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model5_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model5_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 6 (VGG16 + eLU)
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

base_model.trainable = False

model6 = Sequential()

for layer in base_model.layers:
  model6.add(layer)

# Capas sustituidas
model6.add(Flatten())
model6.add(Dense(units=4096, activation='elu'))
model6.add(Dense(units=4096, activation='elu'))
model6.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model6.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model6.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model6.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model6.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model6_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model6_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model6_vgg16.png')
plt.clf()

# Arquitectura de la red neuronal 7 (VGG16 + ELU + L2)
base_model = VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(224, 224, 3))

base_model.trainable = False

model7 = Sequential()

for layer in base_model.layers:
  model7.add(layer)

# Capas sustituidas
model7.add(Flatten())
model7.add(Dense(units=4096, activation='elu', kernel_regularizer=regularizers.l2(0.001)))
model7.add(Dense(units=4096, activation='elu', kernel_regularizer=regularizers.l2(0.001)))
model7.add(Dense(units=num_classes, activation='softmax'))

# Compilación y entrenamiento del modelo
model7.compile(optimizer=tf.keras.optimizers.Adam(0.0005), loss='categorical_crossentropy', metrics=['accuracy'])
history = model7.fit(train_generator, epochs=10, validation_data=test_generator)

# Evaluación del modelo con los datos de test
loss, accuracy = model7.evaluate(test_generator)
print(f"Loss: {loss}, Accuracy: {accuracy}")

Y_pred = model7.predict(test_generator)
y_pred = np.argmax(Y_pred, axis=1)
y_true = test_generator.classes
report = classification_report(y_true, y_pred, output_dict=True)

df = pd.DataFrame(report).T
df.to_excel('report_model7_vgg16.xlsx', index_label='Class')

# for class_label, metrics in report.items():
#     if class_label.isdigit():
#         class_name = list(test_generator.class_indices.keys())[int(class_label)]
#         print(f"Class {class_label} ({class_name}):")
#         print(f"Loss: {loss}")
#         print(f"Accuracy: {accuracy}")
#         print(f"Precision: {metrics['precision']}")
#         print(f"Recall: {metrics['recall']}")
#         print(f"F1-Score: {metrics['f1-score']}")
#         print("-------------")

# Gráfica de pérdida (loss)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
# plt.savefig('loss_model7_vgg16.png')
plt.clf()

# Gráfica de precisión (accuracy)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
# plt.savefig('acc_model7_vgg16.png')
plt.clf()
